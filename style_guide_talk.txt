styleguide1.mp4

[00:13] Ah, esses primitivos Em vez de ser no chá, ser no type
[00:39] Colocar tudo no type O primitivo ali Colocar tudo dentro do type Tudo que é postulate Primitivo, colocar dentro do type Dentro do type o que?
[00:58] O primitivo ali Primis, hex, digit, char, bool. Já vi. Botar tudo dentro do type. Pra ficar tudo no tipo. O que é botar dentro do type? É botar tudo no arquivo chart type.
[01:14] Você tá declarando esse primitivo. Isso daí tu declara dentro do type. Não no arquivo index digit. Tu vai botar dentro do arquivo type. Mas por que que vocês decidiram isso?
[01:33] Não, não. eu não concordo também Só Assim pra mim é mais didático Do que, é que não tá no Westerly Lá do Agne Mas é que daí como é que, daí tipo, tu vai entrar na função
[01:45] IsRexDigit e aí tá usando um primitivo Que tu não sabe de onde é que veio, né É, e além do que Não dá pra fazer isso em todos Porque dá erro de recursão mútua O string, por exemplo
[01:58] Então não,. Ao contrário, tem que sair do e pro lugar que tá sendo declarado. Nunca no vamos até botar esse daí dentro do não tem como, senão o vai dar erro em alguns arquivos. Onde que cê tá sendo usado?
[02:34] É no aqui. Que que é isso? Eh só pra não dar conflito provavelmente. Não dá conflito ali embaixo na linha dezessete, dezoito. Entendi. Oi. Tá, vamos por convenção.
[03:14] Nunca ter apóstrofe em nome, tá? Coloca aí. Guideline. Não pode nunca, nunca, sob hipótese nenhuma, ter apóstrofe no nome. Se quiser fazer um negócio desse, faz que seja assim. Mas eu não gosto. Eu prefiro que importe qualificado e faça assim.
[03:46] Não, mas isso funciona? Ah, louco. Não sabia que tinha uma coisa assim. Importa qualificado. Sempre que der clash de importe, vamos combinar que você só importa qualificado um nome talib do tipo
[04:09] outra coisa, não sei se vocês estão percebendo, mas os import tem que ser ordenados por ordem alfabética, tá? convenção então se isso aqui tá errado tem que ficar certo, pode botar a guideline pra isso e esse aqui tá errado
[04:43] e esse erro daqui ainda tá ruim lagdcli ué, tá, depois eu... é isso, né? É, teoricamente é isso. Bom, eu posso deixar que depois eu vou olhar o que deu, mas deve ter sido alguma coisa na hora de passar o repo.
[05:07] Mas eu posso deixar que eu vou olhar de novo. Tá bom. Mas então por que tá dando erro no isHackStage? Ué? Ué? Mas não é erro no is, é erro aí mesmo. Ué? Parou? Não tinha, não tinha. Ué? Eu acho que caderno de f e nels deve ficar assim, tá?
[05:44] Pra mim faz muito mais sentido do que assim. Então acho que por convenção a gente coloca assim mais um negócio meio... O tem no final ali do if, né? O else embaixo com... Especifica isso, colocou alguns exemplos no guideline,
[06:03] mas pra mim fica melhor assim do que assim. Muito melhor, na verdade. Eu vejo um guideline que vai afetar vários lugares. Novamente, preferir... Como guideline geral, sempre que é possível,ir Lash to Queue Error.
[06:27] Eu não gosto muito do Error, acho melhor evitar. Então, aqui já tem alguns erros, por exemplo, se era para ser First, se era para ser Second. Acho que sempre que possível, não for atrapalhar, tentar alinhar os comentários só para ficar bonitinho.
[07:29] Está faltando um ponto, está cheio de falhas de guideline. Essa seta aqui também teria que ajeitar, mas aqui tudo a gente já especificou. Essa seta aí é fácil de ajeitar. Só dá um quebra em cascata. Assim é melhor. Em cascata eu acho mais legível.
[08:01] Os implícitos em cima e os que não são implícitos em cascata. Já tá cheio de erro de guideline, né? A gente não tá fazendo igualzinho, né? Que a gente tá combinando. Não, tu disse três igualdades.
[08:24] É, eu quis dizer três tracinhos igual. Mas tava três trdades. É, eu quis dizer três tracinhas, legal. Mas tava três tracinhas. Eu botei assim, não, muda pra três igualdades. Tá bom. Eu mudei pra três igualdades. Eu botei o que já tava. Eu falei, ah, beleza. Aí tu disse, ó, tu muda pra três igualdades.
[08:40] Ah, tá bom, eu já mudei pra isso. Eu entendi. O que eu quis dizer era três tracinhas. Mas isso aí é Unicode também, né? É Unicode. Não, os Unicodes que eu abri uma exceção. Sim, sim, sim. Não, tranquilo. É só mudar aí no inf o documento de maturidade é bem comum. Não, tranquilo.
[08:56] É, só muda aí no infix, Sonico. Isso aí tá num PR, eu acho. Tá num PR do Kimba. Ele já não tá assim mais, né? Eu vou olhar a parte do float. Tá tudo na nossa branch da ANT.
[09:25] Então, aqui eu faria aquela questão. Aí eu teria que ajeitar o WIFI. Tá, então aqui como regra geral, vamos evitar usar esse operador quase sempre que possível, tá? Tem que importar io.sec.
[10:41] Não, isso tá errado. A função sec a gente tá definindo por convenção junto com o bind. Por exemplo, se você olhar no parser, o bind define o sec. Ah, porque um é escrito em função do outro, né?
[11:02] Então teria que mudar isso também ali. Eu sei que isso escapa um pouquinho da convenção de uma definição por arquivo, mas seria como se fosse um bônus do binding, entendeu? Acho que nesse caso a gente abre essa exceção sim.
[11:25] Na verdade eu não gosto da ideia de abrir exceção, porque a gente só faz que importar o sec meu, mas aí toda vez eu tenho que importar o sec do IO. Enfim, não sei. E o... Calma, e o que? Ah não, aí eu não sei o que. Tô achando que ele não entende esse caso aqui no monad.
[12:00] Nossa, que estranho, velho. Não dá então pra fazer essa conversão do Elze porque ele não entende em certos casos. Mas aí é feio gente, que coisa estúpida. Ali é o Dan com o Elze, não?
[12:29] Não, o problema é que o Elze não pode ficar aqui porque ele acha que é outra função. O lugar do do ali em cima. Ele pensa que é algo a mais. Tem que encapsular tudo dentro de parênteses. Nossa, mas que estúpido viu? Ah, então vamos estabelecer aqui por convenção, o if dentro de do a gente faz assim, pode ser?
[13:41] Uhum. Assim ou assim? Acho que assim fica sendo aceitável quando for dentro de... É porque fica diferente do... quando é com let, quando é normal. Pois é. Vai dar pra... ah, esse daqui é do do...
[14:09] Ah, então vamos combinar que tem duas formas de if aceitáveis. E aí fica pra pessoa escolher, obviamente isso aqui também pode ficar na mesma linha. Eu acho que fica esse aí na mesma linha, o de baixo. Não, mas é porque pode ter mais de uma linha.
[14:24] Mas nem sempre vai dar. Às vezes faz mais de uma coisa. Os dois aí são iguais. Oi, são iguais. Vamos considerar, então, que todos esses aqui são aceitáveis, tá? Tá. Agora, esse daqui fica sendo não aceitável. Então, esses três aqui são aceitáveis.
[14:51] E dentro de um bloco, só vai dar processo 2. O de cima não funciona, infelizmente. Tem mais um pouquinho, por favor. Obrigada. Então, pode seguir. Gente, se eu passar alguma sintaxe que não funciona em algum caso, é só vocês trazerem pra mim, tá? Igual aqui, tipo,
[15:25] a gente não sabia que esse caso aqui não iria funcionar dentro de um view block. Então, aí a gente fica a mercê da vontade do Agatha. Ah, ô, Tairinho, o Henrico perguntou esses dias, eu fiquei pensando
[15:44] também, a sintaxe do case, no nosso caso tem que botar o lambda, né? Antes. Mas no do Agda não precisa, né? Faz sentido ajustar, é proposital ou... Como assim no Agda não precisa?
[16:00] É que no Agda não tem como tu botar só case, alguma coisa off, não sei o que, e tu não precisa abrir o scope de lambda com parênteses. Ou alguém ajeitou isso e eu não vi, se pá.
[16:13] Lambda com parênteses? Com chave. Não, calma. É chave. Com chaves, com chaves. Não precisa sim. Eu vou achar aqui. Pode seguir. Depois se eu achar o que eu explicar melhor isso, daí eu falo de novo. Isso vem do Agda. A gente precisa definir, né?
[16:38] Se a gente realmente vai querer fazer funções assim ou se a gente vai querer usar o if do Agda, né? Qual que vocês acham mais legível? Eu disse... Eu não estou dando esse legível, mas eu prefiro o case off do que o if é, eu prefiro o case off também
[17:59] o problema, gente, eu tô pensando agora acho que o case off, ele tem o Agda, ele tem mais dificuldade, ele sabe melhor entender o if, na hora de provar teorema
[18:11] eu acredito, posso estar enganado, então eu acho que o case é uma, o if é mais entendido, né, pelo computador do Agda, vai ter hora que a gente vai querer provar o teorema e vai funcionar melhor com o if, mas eu posso ter equivocado.
[18:33] Isso é só na hora do testando fazer as provas. Vamos deixar os dois como aceitáveis, só que o problema é que a AI vai ter que escolher um dos dois, o ideal é sempre escolher uma opção.
[19:04] Também acho que o if vai ser mais rápido, porque o caseoff chama a função caseoff aqui, tanto que fica meio gambiarra esse lambda where aqui. O Agda não tem o caseoff nativo, isso daqui é uma função que ele chama tipo if.
[19:21] Parece, é que sei lá, pra mim o caseoff é mais uma questão de gosto, mas faz sentido o que tu tá falando. Até porque o if já é nativo mesmo. Não, o if dele tem que chamar o bool.if. Não, não, o if, no caso.
[19:37] E o if. Vou especificar os dois, como é que deve ser, né? Se for case off, fica assim. Case off, blá blá blá, where, aí os casos, credentação, enfim, nada de surpreendente,
[20:10] só essa certa aqui que tá errada. Esse ou if, assim, né? Tipo, vou deixar até aqui comentado. Vou deixar os dois como possíveis folhas. Depois talvez a gente colhe só um. E aqui, por exemplo, isso daqui é válido,
[20:43] mas se eu quiser identar e usar em outra linha, isso daqui não é válido. Só lembra que vai ter que ficar assim, entendeu? Então quando você... quando cada caso é uma linha, você pode identar o igual, só que também vale pra certa.
[21:00] Identar errado é certa, né? Agora quando você joga pra outra linha, aí você não pode identar. Tá certo os argumentodes, deixar só os...
[21:22] Não mais que é lambda, for all e o igualdade. Nossa, tem muita coisa pra ajeitar. Olha a quantidade de setinha que tá errada. Aqui vale aquela mesma coisa, tá, gente? É, preferir... É, eu dou no LED.
[22:00] Eu vou fazer aqui, mas não deveria fazer. Agora eu tô livre pra fazer isso daí. Você não vai tomar processo. Nossa, esse lugar... É, então, aqui tem uma coisa que eu acho importante. Eita, eu tô cor retorno na minha voz. Na verdade, deixa eu pegar pra ver se vocês já estão entendendo.
[22:48] Apontem pra mim todos os erros que vocês encontram nesse arquivo. Let in, where, let. É, a mão de cada vez. Let in... Mais de cima. Mais o quê? Os importes não estão em ordem alfabética. Os importes não estão em ordem alfabética.
[23:12] O comentário tá errado. É, o comentário não tá no estilo, né? Eu tenho que levar esse DR aqui. Isso aí eu não tenho o que fazer agora. Tá errado. É, o comentário não tá no estilo, né? Tem que ter mais terra aqui, isso aí eu não tenho que fazer agora. Não, tá de mão. Eh tem o era ali e a flechinha também tá errado. Flechinha agora. Mas que? Os espaçamentos não tão os mesmos
[23:36] ali embaixo no ah acho que tá. É o letinha ali embaixo da vinte tem som letinho. Na trinta e sete, na quarenta tem letinho
[23:57] também. Mas que? Tem uma coisa que a gente não falou ainda, mas tá errado. Essa identificação do ar ali, na minha
[24:18] cabeça, eu não precisava colocar isso. É, pra mim o é errado de alguma forma, mano. Pra mim o não deveria usar o e colocar tudo em cima, que gente quer ou abaixo e for chamando.
[24:30] Mas a auxiliar fica em cima. Eu concordo bastante com isso. A auxiliar fica em cima e... E dá pra setar como private, né? Porque pra não dar name class quando tu for importar o arquivo.
[24:46] Eu sou contra a coisa private, tá? Eu colocaria assim e não colocaria nada de private não. É assim que eu tô fazendo na nova definição ali algumas funções de IK que eu tô fazendo desse jeito por causa do compilador em JavaScript.
[25:00] Não, tudo bem, mas só o que eu quis dizer é que, por exemplo, se tu vai definir uma função que tem um nome muito comum, aí é meio... ou tu usa um nome bem específico que não vai repetir, né? Se alguém for usar... Se você é auxiliar daquela função, tu bota coisa daquela função.
[25:14] Acho que a gente pode colocar o nome do tipo na função auxiliar. Vai botar o Godown. O arquivo define uma função com o nome do arquivo. Se você está importando, você já sabe o nome que vai vir.
[25:32] Mas é que aí... É, sim, nesse caso você teria que importar qualificado. Mas, por exemplo, eu estou fazendo uma árvore e importo esse hash de string por algum motivo. Eu estou implantando um rotate left na minha árvore, eu vou tomar um erro ali, né? Teoricamente, pra quem ler, o certo seria vir só o hashing.
[25:52] Então, só no RotateLef e no Hashing. O problema é que tem uma função chamada RotateLef no arquivo do hashing, isso que eu tô falando. Isso daqui tem que ser o próprio arquivo. Ah, tá, entendi. Mas aí, tu sempre definiria os helpers em arquivos diferentes.
[26:09] É, eu acredito que... Não, é porque isso daqui não é bem um helper tipo Go. Isso daqui é um helper tipo... Que é uma função, sabe? Sim, sim. A helper quer uma função, sabe? Sim, sim. Mas é uma auxiliar, ela não precisa de um arquivo separado.
[26:23] Não, isso daqui precisa, é isso que eu tô falando. O hash step não, mas o hash sim. O rotate sim. Precisa sim, você pode querer usar o step da função hash em outra situação.
[26:36] Tá, justo. Pra mim são funções bem complicadas que deveriam ser uma função própria. Eu concordo, acho que faz sentido sim. Tipo, se uma função chega a esse tamanho, pra mim é um arquivo próprio, sabe? Tem sentido. Aí o que que faria? Pra mim faria um diretório chamado string barra hash
[27:07] e colocaria uma função chamada step lá dentro. Deveria ser tipo data ponto string ponto hash ponto step. Isso daqui seria data ponto string ponto hash ponto potente left.
[27:24] Isso daqui poderia ser data ponto string ponto... Na verdade isso daqui não deveria existir, né? Deveria ser um deveria assistir pegou? você fez o u eu fiz um um de tipo sim, tipo
[27:49] você falou pegou errado nisso daí ali no 20 não, não, não, tá dentro tá argumento dentro do argumento gente, nem consegue ver
[28:07] isso tá me causando tanto toque é o parênteses no upper? isso, aqui os parênteses no upper? Isso, aqui os parênteses. Aqui também. É que eu sou amigo dos parênteses, eu gosto de botar. Não fui eu que fiz essa, mas eu tenho que tirar das minhas.
[28:29] Mas aí no upper mais lower ali tu tiraria também, né? Na 24. Precisa, né? Real. Boa. Então, evitar parênteses desnecessários, tá? Como guideline, vamos ser econômicos em parênteses. Que o Agda é assim.
[28:49] Aqui pra mim tá o que já, tá? Então foram muitas coisas. A única coisa é que eu colocaria isso nos arquivos próprios. Nossa! Caraca! Meu Deus, eu estava no lugar errado. É... Tá, acho que aqui está ok.
[29:17] É que vai aquela coisa, né? A gente usa o if ou a gente usa caseoff.
[pausa]
styleguide2.mp4

[00:15] Eu acho, gente, que como regra geral, a gente tem que usar o if. Real, eu acho que o Agda é mais feito para usar o if, sabe? Então, eu colocaria como guide a gente não fazer o case off, fazer as coisas com o if em geral.
[00:36] E tem muito aqui porque usa case off. É porque, tipo assim, case off é mais lerdo, é feio, porque no Agda fica esse lambda where, eu acho que é inevitável. É uma função que você tem que importar sempre, então esquece de importar.
[00:50] Não sei, não sou muito fã do caseoff, não. Não é nativo, não é built-in. Acho que, em geral, a gente evita tanto caseoff quanto bool.if. Então, assim, regra geral, vamos no guideline evitar caseoff e bool.if. Vamos usar o próprio if do Agda.
[01:09] Pode ser? Pode. Nossa, muita coisa aqui, né? Certo, tá errado. Comentário do Ian. Flip it, second. Tu vai receber um PR com esse dias justiços que você está fazendo agora? não para terminar aqui para abrir alguma coisa
[01:51] mudanças eu acho que sim na verdade uma identificação só mas como preferência para mim o where tem que ficar na linha de cima tipo isso é um uso aceitável de where mas em geral coloque ele no guideline
[02:05] e faça a função em cima e se for uma função muito distinta fazer um arquivo a parte. Isso aí. Isso não seria outro arquivo? Seria pra data ponto
[02:24] string ponto LTE ponto gol. Chamaria de gol. List, né? Pode ser lista mesmo, mas na verdade isso é estúpido, né? Isso daqui deveria ser isso daqui deveria ser data ponto
[02:48] list ponto LTE com parâmetro org. Sacou o que eu quero dizer? Sim, sim, sim. O org não está feito. Mas quando fizer, não vai precisar mais de ser a list ali. É o Sandro que está fazendo, não é?
[03:16] Aqui também está errado, né? Porque deveria ser import data.char.lte. Estão anotando isso tudo, né, gente? Sim. Estou gravando aqui também. E o menor e igual deveria ser char. Obviamente, na causa da lista, vai ser parametrizado no ordem.
[03:53] Esse algoritmo aqui está meio de pebre, não é assim mesmo? Estou meio que gastando atenção. Está esquisito. Chat. O first aqui é para alinhar, botar bonitinho. Seguindo a convenção. Esse algoritmo aqui eu não sei se eu uso.
[04:43] Alinhar. Certinho, vamos fazer no outro lado. O ponto final. Eu tenho uma pergunta. Na definição da função, os tipos ficam alinhados com os parâmetros?
[05:02] Não, nunca, nunca. Isso aqui não, você está falando disso, né? É, aham. Não, isso aqui não. É esse negócio lá, fazer um let, evitar o error a todo custo.
[05:22] Evitar o error a todo custo. Esse aqui não está no padrão, tem que ser ou assim, ou só dar uma hidratação que ele já está no padrão. Evitar where, tudo custo, isso aqui deveria mover para o arquivo próprio.
[05:46] Eu imparia uma pasta para isso e colocaria lá dentro. Isso aqui também a gente vai evitar if, então como a gente vai evitar o if, a gente vai usar o if de preferência. Aí dá para usar o word também.
[06:15] Sim, aí também tem os comentários que estão faltando, mover para outro arquivo, mas acho que vocês já pegaram a ideia. Será que dá pra ficar numa linha? Dá. Ah, eu acho mais bonitinho assim, viu? Se tiver mais que primitivo, faz um embaixo do outro, né? Se não, é uma linha.
[06:35] Postulate também dá pra fazer isso. Postulate também. Porque geralmente, o primitivo vai estar no arquivo que define a função exportada, né? Então, geralmente vai ter só um. Quase sempre vai ter só um. Aí aqui, né? A gente vai preferir o IF, né? A gente pode colocar, tá? Pode
[06:55] estabelecer como regra geral, vamos preferir o IF e não usar o case-off. Vamos purgar case-off. Fazer uma pergunta bem burra. Oi? Fazer uma pergunta bem burra. Ah, o, se a gente fizer o nosso um pro IF, a gente não ganharia em performance pra
[07:15] aparecer um alias? Que que é um alias pro IF? Um um Um apelido, um... Um boolif só Replicar o... O boolif só replicar esse leaf aí Calma, calma
[07:31] Ok, eu nem entendi um anúncio pro if, como seria isso? Ele quer dizer tipo... É que eu não sei se daria a sintaxe, mas tipo... Tá ligado a sintaxe pra criar list... Pra criar uma lista que tu só bota o... Enfim, a sintaxe de criar lista
[07:43] Que tem no Agda Ele tá falando de fazer a mesma coisa do if Só que pro if. Em vez de tu escrever o if to não sei o que, tu escreveria o if, mas na prática ele estaria fazendo a mesma coisa. Mas eu não sei se tem como fazer isso.
[07:56] É, você estaria escrevendo como se fosse o bool if. Calma, você tá falando do bool if. Gente, vocês estão falando... Mas é porque são coisas diferentes, porque um é pattern match, né? Calma, gente, eu tô muito confuso. Você tá falando do bool if. Isso. Do bool if. Do deno else. isso do Daniel a gente tem esse
[08:20] WIFI aí que tu tá fazendo agora WIFI que é um WIFI um WIFI ele tem algo que aplica um WIFI
[08:42] assim no chat ruim é exatamente porque a gente só vai tá refazendo o WIFI só que com outra uma forma mais tradicional das pessoas escreverem, quando elas virem elas vão entender.
[09:01] Mas é que não é a mesma coisa... Ah, entendi. Você quer que você escreva o if, mas ele compile pro if. Isso, exatamente. Entendi. Não, mas eu acho, eu acho assim, que na verdade, é porque eu falo de performance, mas assim, eu acho que na performance,
[09:16] isso daqui, o if já é inline, então também não acho, eu não sei se vai ter impacto. Pode ter. Pode. Mas eu acho que na prática. O compilador do Haskell vai tirar. O do JavaScript provavelmente não. Na verdade. O JavaScript provavelmente vai se ferrar com o If.
[09:31] E imagino que o If seja melhor para o compilador do JavaScript. Porque o compilador do JavaScript não faz inline. Então toda função que você chama. Ele realmente chama. E vai chamar uma função à toa. Mas alias no Agda não tem como. Tipo. Você mandar o Agda. Na verdade. Procurei no Google.
[09:46] Tem uma coisa no Agda. Que é rewrite. Talvez dê pra usar pra isso, mas eu não sei se como é que funciona. Enfim, não sei responder se tem que fazer. Mas assim, eh eu entendo que o é mais fácil de ler, né? Mas depois você acostuma, tipo,
[10:06] cê vai perceber que assim, um de um booleano, um com falso, cê vai tipo nativamente já é igual um né? Na real, é bem parecido. A única coisa que me incomoda desse whiff é esses três pontinhos aí, pra mim podia não ter, mas...
[10:24] Pois é, eu fiquei pensando nisso, e aí eu não lembro o que foi que eu... sabe, acho que eu sabe o que fez, que era... ah, foi do bend, o whiff era só um pattern match no bend.
[10:38] Então, mas o whiff não é só um pattern match, é porque na verdade, o que o whiff faz? Ele dá um pattern match nisso, é porque... ó, vamos lá, pra vocês entenderem a lógica disso. No Agda, por exemplo, você tem uma função de bool para bool para bool.
[10:53] Aí você pode fazer um if, você pode receber o x e o y, e fazer um if x, then, blá, blá, blá, else, deixa eu botar embaixo, blá, blá, blá. Isso é natural no Agda. Só que o que acontece? O Agda, isso é natural em todos os linguagens, na verdade, não só no Agda.
[11:11] Só que no Agda, a gente tem a opção, e no Haskell, a gente tem a opção de não no Haskell, né? A gente tem a opção de não fazer um if-then-else e fazer o pattern-match na equação e criar duas equações. Então, agora você vai fazer duas equações diferentes
[11:23] e cada equação só acontece em um dos casos que você deu pattern-match. Então, aqui é uma equação com if, só que aqui é duas equações com pattern-match nativo. Então, você pode fazer isso no Haskell e no Agda. Só que o Agda fez a seguinte pergunta,
[11:37] tá, mas quando você quiser usar mais de uma equação só que por um valor que não é um dos argumentos, um valor que você criou dos dois argumentos. Então, por exemplo, vamos supor que você tenha agora um negócio assim
[11:50] if end x, y x end y then else vamos supor que você tenha isso na forma que não tem equação na forma que é uma equação só. Se você
[12:05] tem isso, você não tem a opção de esplitar isso em duas equações. Porque o que você está dando o if não é no argumento x nem no argumento y. É uma coisa derivada dos dois. Então como você splita isso em duas equações se é uma coisa derivada dos dois?
[12:23] Você não tem como. E também que falou, pô, essa sintaxe de splitar, ela é meio incompleta. Porque você consegue splitar em mais de uma equação. Se for um argumento, mas se for algo construído com argumento, você não consegue splittar em mais uma equação.
[12:37] Aí o que ele fez? Ele inventou a sintaxe with para literalmente isso. Tipo, com x e y. Então é como se a gente fizesse isso daqui se tornar um terceiro argumento fake da função. E agora como é um terceiro argumento fake, você consegue splittar em duas equações.
[12:59] Você criou um terceiro argumento só para fazer isso. E agora você consegue splittar em duas equações igual você tinha feito aqui antes. Aqui a gente consegue fazer. A gente está dando if no x, que é um argumento. Só que aqui a gente não consegue splittar em mais de uma equação, porque a gente
[13:13] está dando if numa coisa construída com dois argumentos. Aí você usa o if para criar um terceiro argumento fake, e aí você consegue fazer split. Porque basicamente os caras do Agda adoram splittar a equação e evitar
[13:26] if e evitar case. É basicamente isso. Então eles encontraram uma justificativa Pra conseguir splittar até onde Não daria pra splittar no Haskell E agora eles conseguem fazer tudo splittado em equação Que o Agda adora splittar em equação
[13:39] Só que aí fica feio Porque fica repetido o full xy E aí pra evitar repetição Eles fizeram um alias E você consegue botar os três pontinhos Entendeu? Então a ideia é que na verdade
[13:51] Esses três pontinhos é uma abreviação De full xy repetido várias vezes. Só pra você entender a ginástica mental que chegou lá. Mas assim, se você quisesse você poderia fazer assim, né? Eu acho, tá gente? Não sei se vai funcionar, mas
[14:08] em tese deveria funcionar. É, eu fui burro, né? Isso daqui era o... Não, esse daqui pra mim deveria funcionar. Não sei porque não funcionou. Falta alguma cláusula? É o noni que tu tá
[14:34] fazendo, tá minúsculo Não, tem nada a ver Só que tá faltando uma cláusula, não sei qual É o AC O ACC ali, depois do C e CS
[15:01] Ah, tá Burro, quem diria Nossa Ainda tá faltando Tá E o Agda não me ajuda, né?
[15:27] Não sei Ela tá reclamando da linha 40. Não é aí não, é na linha 40. O que tem na linha 40? Linha 40. Ah, não. É 340. É coluna 40, linha 28. Linha 28. Só que a gente tá dando o if nisso e a gente tá cobrindo os dois casos disso.
[15:50] Só que eles tiraram já, colocaram só o coisa mesmo? Deixa eu pedir pro Soneto. Ah, calma. Acho que eu já sei. Acho que a syntax na hora que eu falei não. Acho que a syntax tem um... Pipe. tem um pipe Tem um pipe É isso Então basicamente Quando você cria um argumento fake
[16:18] Você só tem que separar com pipe E aí pra não ficar repetida a linha Você coloca três pontinhos Mas a ideia é que você tá como se você estivesse criando Ai, eu apaguei, eu sou burro A ideia do if é que você tá criando equações extras
[16:31] Entendeu? Onde já nem parece tão feio O fake que você fala É tipo uma suposição sem prova? Não, estou dizendo que a gente está criando uma equação, splitando uma função, uma equação em duas,
[16:54] a gente está splitando uma equação em duas, sendo que não teria como, porque a gente está splitando baseado em um argumento que não existe, e a combinação é de dois outros argumentos. Então a gente cria um terceiro argumento fake, o placeholder não é fake, porque a função é de dois argumentos.
[17:10] E aí a gente não tem como splitar em uma coisa que não é um argumento. Então a gente vai criar um argumento terceiro, que é esse daqui, para splitar nesse argumento terceiro. E aí a gente nunca, em tese, a gente nunca precisaria de if nem case e of.
[17:24] Essa que é a ideia. A gente pode splitar tudo em equação. Com essa síntese dá para, por exemplo, aqui a gente está fazendo três, né? Tu conseguiria fazer com quatro argumentos? Tu criar dois extra mas só de curiosidade não sei como vou te como te cobrir
[17:40] isso agora eu acho que tem que eu já vi prova em Agda do que eu tava fazendo o path em pet find tinha argumento lá que tinha if embaixo tinha mais if if mas é que nestando o if deve dar mas tipo
[17:55] quiser no mesmo ah tá na mesma linha né é isso eu vi que tem cadeia, faz um e vai outro, vai outro, vai outro Eu fiz o Dicxdrat, sei lá, o coisa que eu fiz em grafo
[18:27] Ai meu Deus, poxa ele errou o arquivo O fine tune resolve isso né, quando o coder é o arquivo é triste Errou o arquivo, ele fez uma loucura
[18:47] Ele não criou o arquivo Ele espera que o arquivo tenha criado Isso é uma coisa que a gente pode ajeitar também lá, né? Mas eu também sou bool. Eu pedi pra fazer bool.foo e não data.bool. Mas tudo bem. Era só pra responder a nossa pergunta.
[19:06] Então, assim, você coloca um pipe a mais e aí você consegue fazer mais de um argumento fake. Legal. Então, tá, você pode ter 500 argumentos fakes. E aí, se pular lá, nunca precisar. Tá o check disso aí? Só pra ter certeza? Não dá pra dar check porque tá no lugar errado, né? Calma. Ah, tá. Ah, eu também tinha aberto o arquivo errado.
[19:28] Então, na verdade, a culpa é toda minha. Ah, tem que importar, mano. O end wall. Caraca, eu fico assustado com as vezes, tipo, aqui tá, importa o end wall, ele já importa o agora falta importar o end wall, tipo, como que um computador sabe ter essa percepção de aí
[20:07] funciona? Então dá pra criar meus ali. Cara, eu ainda assim, eu, sábio, eu prefiro fazer um auxiliar com coisa a mais do que fazer com o if.
[20:19] Não sei. Mas é mais elegante esse if. Sim, é mais elegante, isso é. É mais visual, é mais bonito. Isso eu não tenho dúvida. Começa assim, daqui a pouco a gente está escrevendo os hieroglifos. O cara que olha o nosso código correto.
[20:45] Sabe, você começa assim, ah, não, vamos aceitar o if, vamos aceitar isso, vamos aceitar o unicode do igual a igual. Daqui a pouco a gente está escrevendo, os caras acham que a gente sai de uma pirâmide. Inclusive tem Unicode ali, que eu vi em algum ponto. É, tem o Sigma ali.
[20:59] Aí, ó. É, o Sigma acabou de passar ali. Esse Sigma é porque, tipo assim, ele é o contraparte do Forall, né? Ele também é um símbolo muito fundamental. Então ele eu também acho que justifica o Unicode. Então tem quatro
[21:14] símbolos. Lambda, Forall, a do Equality e agora o Sigma. O que que esse A do equality E agora o sigma O que esse sigma está fazendo aí? Nada, né? Podia ser só um par Porque não está usando esse argumento
[21:28] Então esse daqui também é de proerb Esse daqui deve ser só um par mesmo Não está usando, não está para nada Ah não, é porque o prim string com cons Usa o sigma porque o agda Usa o sigma como par
[21:48] Então é o primitivo deles Aí a gente não tem opção, tem que usar Nossa, é muito estranhoho sigma não usar argumento não é tudo bem não ele calma é porque eu tenho que explicar pra vocês o que que é o sigma é vamos
[22:05] o que deixa não mas é então vamos lá mini aulinha aqui de águeda é nas linguagens não dependentes né a gente tem o conceito de uma função simples então por exemplo F pode ser uma opção que recebe
[22:18] um inteiro e retorna o string aí tudo bem é uma opção que recebe inteiro e retorna string. Isso daí até no C tem, até no JavaScript em tudo tem. Só que quando você tem uma função dependente, o que vai acontecer?
[22:31] É, vamos supor que seja um booleano, tá? F é uma função que recebe um booleano e retorna uma string. Uma função dependente é uma extensão do conceito do tipo de uma função que permite com que o retorno de uma função dependa do input dela. Então, o output, o tipo do output, agora depende do tipo do input. Como que você escreve
[22:49] uma função dependente? Você vai fazer o forAll, vai dar um nome para o input, e aí você vai dizer o output. Qual é a diferença disso? A diferença é que agora, aqui no retorno, eu posso acessar o valor do input. Então, por exemplo,
[23:05] ao invés de dizer f é uma função que retorna um booleano e retorna um string, eu posso dizer f é uma função que recebe um booleano chamado x e retorna, se o x for true, uma string,
[23:20] senão um NAT. Isso é impossível de fazer numa linguagem, num tipo não dependente. Vou dar um exemplo de uma aplicação disso aqui agora. Vou criar aqui um foo.arg, daria uma opção aleatória,
[23:34] pedir para o soneto escrever, né? create a foo function que recebe um booleano and returns if that bool is true a NAT otherwise a string. Então isso daqui
[23:53] gente deixa ele escrever pra gente pra vocês entenderem. Ele fez cagada né. Colocou o item ali. Ele fez um esqueleto eu faço a replica. Então olha que interessante essa função recebe um booleano e ela vai retornar se o booleano for true um NAT, se não um string.
[24:45] E aí, aqui nos nossos contextos, num caso ele pede NAT, num outro caso ele pede string. Então aqui eu vou retornar 50, e aqui eu vou retornar... Isso funciona. E também eu acredito que deveria funcionar, não sei se com o if ele vai conseguir fazer isso, porque é um tipo dependente, mas vamos ver. Ah, não, não conseguiu. Porque... É por isso que eu falo que o if é melhor, né? Tipo, quando você faz o pattern match nativo,
[25:18] ele consegue. Aqui não, aqui o tipo está mantendo como o if xdenat as string vamos ver se retornar o case aqui ele vai pro crachá ah não ele entendeu ele é esperto oxe não ele perde o nat
[25:30] porque pra ficar é porque o if tem o tipo simples mas eu acho que com case off deixa eu ver o function porque a gente tem o case off dependente que é esse daqui então se a gente usar esse daqui a gente consegue vamos ver se eu consigo fazer isso aqui funcionar que existe return off
[25:52] lambda where do a gente também poderia ter um um if dependente é porque a gente não tem ainda vamos ver se aqui a gente consegue aí funcionou então a gente poderia deixa eu ver se eu consigo
[26:23] fazer um if dependente aqui ah foi aquelagraça lá que eu fiquei pensando por uns três dias pra fazer com self types. No é. Tá, aqui o só
[26:50] que esse eu acho muito feio gente, deixa eu botar só mudar aqui aproveitar caso a gente use isso um dia muito feio eu acho que é não mas eu acho que ele não aceita também o
[27:38] argumento ser o último viu? Acho que não reserved não. Eu prefiro as. Tô nem aí se eles gostam de retanhar o tamanho dessa palavra. Ai, mas aí parece que o x é o... Ah, deixa eu pensar.
[28:02] Deixa eu raciocinar... raciocinar... raciocinante. Deixa eu pensar. Belha, ousado... E como que o belha é ousado aqui? Ele não pode ser o último. Por mais que ficaria mais bonitinho...
[29:01] Ah, deixa eu pensar. Ah, o retanhing é melhor. Mas é feio, hein? O banho é melhor. O maré feio, hein?
[pausa]
